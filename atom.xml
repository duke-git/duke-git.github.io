<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柳叶刀的IT技术博客</title>
  
  <subtitle>专注于IT技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-21T10:22:35.779Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>柳叶刀</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于vue-cli-plugin-electron-builder构建Electron + vue-cli3.0的桌面应用开发</title>
    <link href="http://yoursite.com/2019/08/21/vue-electron-dev-post1/"/>
    <id>http://yoursite.com/2019/08/21/vue-electron-dev-post1/</id>
    <published>2019-08-21T07:42:59.000Z</published>
    <updated>2019-08-21T10:22:35.779Z</updated>
    
    <content type="html"><![CDATA[<p>​        <strong>概述</strong></p><p>​        使用electron和vue结合可以构建强大桌面应用。目前，桌面应用开发中electron和vue和开发框架多使用<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/" target="_blank" rel="noopener">electron-vue</a>。electron-vue 充分利用 <code>vue-cli</code> 作为脚手架工具，加上拥有 <code>vue-loader</code> 的 <code>webpack</code>、<code>electron-packager</code> 或是 <code>electron-builder</code>，以及一些最常用的插件，如<code>vue-router</code>、<code>vuex</code> 等等。但是，electron-vue是vue-cli2的版本，且长久没有更新。vue-cli3已经面世很久。其配置简洁，文件结构更加合理。本文展示最新vue和electron框架：vue-cli-plugin-electron-builder，结合vue-cli3创建一个计算个人身体指数（BMI）的桌面应用。</p><p>​        <strong>首先了解vue-cli-plugin-electron-builder工具</strong><a href="https://nklayman.github.io/vue-cli-plugin-electron-builder/" target="_blank" rel="noopener">点击这里</a> </p><p>​        <strong>myBMI桌面应用项目：<a href="https://github.com/duke-git/my-bmi-desktop" target="_blank" rel="noopener">git仓库地址</a> 欢迎start <a href="http://pwkrg9wgk.bkt.clouddn.com/myBMI%E8%BA%AB%E4%BD%93%E6%8C%87%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%20Setup%201.0.1.exe" target="_blank" rel="noopener">myBMI安装文件下载 </a></strong>欢迎下载使用</p><p>​        <strong>应用截图：</strong>    </p><p><img src="http://pwkrg9wgk.bkt.clouddn.com/my-bmi-desktop1.png" alt></p><a id="more"></a><p><img src="http://pwkrg9wgk.bkt.clouddn.com/my-bmi-desktop2.png" alt></p><p><img src="http://pwkrg9wgk.bkt.clouddn.com/my-bmi-desktop3.png" alt></p><p><strong>一，搭建项目</strong></p><ol><li><h5 id="用vue-cli3创建一个项目。"><a href="#用vue-cli3创建一个项目。" class="headerlink" title="用vue-cli3创建一个项目。"></a>用vue-cli3创建一个项目。</h5><p><strong><em>vue create my-bmi-desktop</em></strong></p><p><img src="http://pwkrg9wgk.bkt.clouddn.com/vue-cli3-step1.png" alt></p></li><li><p>#####安装vue-cli-plugin-electron-builder生成器。</p><p>创建完成后cd 到项目目录，添加vue-cli-plugin-electron-builder生成器。</p><ul><li><strong><em>cd electron-vue-my-bmi-desktop</em></strong></li><li><strong><em>vue add electron-builder</em></strong></li></ul></li></ol><p><img src="http://pwkrg9wgk.bkt.clouddn.com/vue-cli3-step2.png" alt></p><ol start="3"><li><p>#####项目工程目录</p><p>参考下图说明：</p><p><img src="http://pwkrg9wgk.bkt.clouddn.com/my-bmi-desktop-project-structer.png" alt></p></li></ol><p><strong>二，项目构建</strong></p><ol><li><p>设置构建参数：vue-cli-plugin-electron-builder打包构建用的是<a href="https://www.electron.build/" target="_blank" rel="noopener">electron-builder</a>。构建参数在vue.config.js中pluginOptions 》electronBuilder 》builderOptions选项中设置。以下是myBmi项目的构建参数：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">electronBuilder: &#123;</span><br><span class="line">    chainWebpackMainProcess: config =&gt; &#123;</span><br><span class="line">        // Chain webpack config for electron main process only</span><br><span class="line">    &#125;,</span><br><span class="line">    chainWebpackRendererProcess: config =&gt; &#123;</span><br><span class="line">        // Chain webpack config for electron renderer process only</span><br><span class="line">        // The following example will set IS_ELECTRON to true in your app</span><br><span class="line">        config.plugin('define').tap(args =&gt; &#123;</span><br><span class="line">            args[0]['IS_ELECTRON'] = true</span><br><span class="line">            return args</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // Use this to change the entrypoint of your app's main process</span><br><span class="line">    mainProcessFile: 'src/background.js',</span><br><span class="line">    // Provide an array of files that, when changed, will recompile the main process and restart Electron</span><br><span class="line">    // Your main process file will be added by default</span><br><span class="line">    mainProcessWatch: [],</span><br><span class="line">    // [1.0.0-rc.4+] Provide a list of arguments that Electron will be launched with during "electron:serve",</span><br><span class="line">    // which can be accessed from the main process (src/background.js).</span><br><span class="line">    // Note that it is ignored when --debug flag is used with "electron:serve", as you must launch Electron yourself</span><br><span class="line">    // Command line args (excluding --debug, --dashboard, and --headless) are passed to Electron as well</span><br><span class="line">    // mainProcessArgs: ['--arg-name', 'arg-value']</span><br><span class="line">    builderOptions: &#123;</span><br><span class="line">        "appId": "com.mybmi.app",</span><br><span class="line">        "productName": "myBMI身体指数计算器",//项目名，也是生成的安装文件名，即aDemo.exe</span><br><span class="line">        "copyright": "Copyright © 2019 柳叶刀",//版权信息</span><br><span class="line">        "directories": &#123;</span><br><span class="line">            "output": "./dist"//输出文件路径</span><br><span class="line">        &#125;,</span><br><span class="line">        "asar": false,</span><br><span class="line">        "win": &#123;//win相关配置</span><br><span class="line">            "icon": "./public/app.ico",//图标，当前图标在根目录下，注意这里有两个坑</span><br><span class="line">            "target": [</span><br><span class="line">                &#123;</span><br><span class="line">                    "target": "nsis",//利用nsis制作安装程序</span><br><span class="line">                    "arch": [</span><br><span class="line">                        "x64",//64位</span><br><span class="line">                        "ia32"//32位</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "nsis": &#123;</span><br><span class="line">            "oneClick": false, // 是否一键安装</span><br><span class="line">            "allowElevation": true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。</span><br><span class="line">            "allowToChangeInstallationDirectory": true, // 允许修改安装目录</span><br><span class="line">            "installerIcon": "./public/app.ico",// 安装图标</span><br><span class="line">            "uninstallerIcon": "./public/app.ico",//卸载图标</span><br><span class="line">            "installerHeaderIcon": "./public/app.ico", // 安装时头部图标</span><br><span class="line">            "createDesktopShortcut": true, // 创建桌面图标</span><br><span class="line">            "createStartMenuShortcut": true,// 创建开始菜单图标</span><br><span class="line">            "shortcutName": "myBMI", // 图标名称</span><br><span class="line">        &#125;,</span><br><span class="line">        "publish": [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"provider"</span>: <span class="string">"generic"</span>,</span><br><span class="line">                "url": "http://**.**.**.**:3001/download/",//隐藏版本服务器地址</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建项目: 构建项目执行命令<strong><em>npm run electron:build</em></strong>。执行会生成dist及electron_dist构建目录。dis构建输出目录由vue.config.js文件builderOptions》directories》output选项指定。目录中包含可执行程序包和程序安装文件（此处build平台为windows）。参考下图：</p><pre><code>![](http://pwkrg9wgk.bkt.clouddn.com/my-bmi-build-directory.png)</code></pre></li></ol><p><strong>三，遗留问题</strong></p><ol><li>electron打包后安装文件体积过大（103M），后期会focus在减少打包文件体积。</li><li>为应用加上自动更新（electron-updater）。</li></ol><h2 id="欢迎浏览区讨论"><a href="#欢迎浏览区讨论" class="headerlink" title="欢迎浏览区讨论"></a>欢迎浏览区讨论</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        &lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​        使用electron和vue结合可以构建强大桌面应用。目前，桌面应用开发中electron和vue和开发框架多使用&lt;a href=&quot;https://simulatedgreg.gitbooks.io/electron-vue/content/cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;。electron-vue 充分利用 &lt;code&gt;vue-cli&lt;/code&gt; 作为脚手架工具，加上拥有 &lt;code&gt;vue-loader&lt;/code&gt; 的 &lt;code&gt;webpack&lt;/code&gt;、&lt;code&gt;electron-packager&lt;/code&gt; 或是 &lt;code&gt;electron-builder&lt;/code&gt;，以及一些最常用的插件，如&lt;code&gt;vue-router&lt;/code&gt;、&lt;code&gt;vuex&lt;/code&gt; 等等。但是，electron-vue是vue-cli2的版本，且长久没有更新。vue-cli3已经面世很久。其配置简洁，文件结构更加合理。本文展示最新vue和electron框架：vue-cli-plugin-electron-builder，结合vue-cli3创建一个计算个人身体指数（BMI）的桌面应用。&lt;/p&gt;
&lt;p&gt;​        &lt;strong&gt;首先了解vue-cli-plugin-electron-builder工具&lt;/strong&gt;&lt;a href=&quot;https://nklayman.github.io/vue-cli-plugin-electron-builder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;​        &lt;strong&gt;myBMI桌面应用项目：&lt;a href=&quot;https://github.com/duke-git/my-bmi-desktop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git仓库地址&lt;/a&gt; 欢迎start &lt;a href=&quot;http://pwkrg9wgk.bkt.clouddn.com/myBMI%E8%BA%AB%E4%BD%93%E6%8C%87%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%20Setup%201.0.1.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;myBMI安装文件下载 &lt;/a&gt;&lt;/strong&gt;欢迎下载使用&lt;/p&gt;
&lt;p&gt;​        &lt;strong&gt;应用截图：&lt;/strong&gt;    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pwkrg9wgk.bkt.clouddn.com/my-bmi-desktop1.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Electron, Vue" scheme="http://yoursite.com/tags/Electron-Vue/"/>
    
  </entry>
  
  <entry>
    <title>转：javascript工作原理 1 引擎，运行时，调用堆栈</title>
    <link href="http://yoursite.com/2019/08/20/javascript_theory_1/"/>
    <id>http://yoursite.com/2019/08/20/javascript_theory_1/</id>
    <published>2019-08-20T09:10:10.000Z</published>
    <updated>2019-08-20T09:15:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文请查阅<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">这里</a>，本文采用<a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>共享，BY <a href="https://github.com/Troland" target="_blank" rel="noopener">Troland</a>。</p></blockquote><p><strong>这是  JavaScript 工作原理的第一章。本章会对语言引擎，运行时，调用栈做一个概述。</strong></p><p>随着 JavaScript 越来越流行，团队也利用其在他们诸如前端，后端，混合 apps，嵌入设备以及更多设备等开发栈中的不同层面的支持。</p><p>本章系列的第一章，本系列旨在深入 JavaScript  并理解它是如何运行的：我们认为在了解 JavaScript 的构建模块和它们是如何捏合在一起工作之后你将会写出更好的代码和 apps。我们将会分享一些当在创建 <a href="https://www.sessionstack.com/?utm_source=medium&utm_medium=source&utm_content=javascript-series-post1-intro" target="_blank" rel="noopener">SessionStack</a> 时候的经验法则，<a href="https://www.sessionstack.com/?utm_source=medium&utm_medium=source&utm_content=javascript-series-post1-intro" target="_blank" rel="noopener">SessionStack</a> 是一个轻量级的 JavaScript 程序它拥有强壮性和高性能的优点以保持竞争力。</p><a id="more"></a><p>正如 <a href="http://githut.info/" target="_blank" rel="noopener">GitHut stats</a> 所显示的那样，JavaScript 的活跃库和总推送数在 Github 排名第一。其它方面的表现也不会比其它语言落下太多。</p><p><img src="https://user-images.githubusercontent.com/1475173/40289980-03f75c32-5cee-11e8-8b88-6920c354c87e.png" alt></p><p>(<a href="https://madnight.github.io/githut/" target="_blank" rel="noopener">点击查看最新 Github 语言统计</a>)</p><p>如果工程非常依赖于 JavaScript，那么这意味着开发者不得不使用 JavaScript 和其语言生态提供的一切事物，为了能够创造出很酷的软件，就得更加深入地了解 JavaScript 语言的内部工作机制。</p><p>事实上，有很多开发者在每天日常开发中都会使用 JavaScript 但是却不了解其底层的知识。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>几乎所有人都已经听说过 V8 引擎的概念，并且很多人知道 JavaScript 是单线程的或者说是使用回调队列的。</p><p>在本章中，我将会详细地过一下这些概念并解释 JavaScript 的工作原理。有赖于了解这些细节，通过合理地使用提供的 APIs 你将可能写出更好的，非阻塞的程序。</p><p>如果你是新手，本文将会帮助你理解为什么和其它语言比较 JavaScript 是不可思议的。</p><p>如果你是一个经验丰富的 JavaScript 开发者，但愿，它将会让你更加深入地了解 JavaScript 运行时工作原理。</p><h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>谷歌 V8 引擎是流行的 JavaScript 引擎之一。V8 引擎在诸如 Chrome 和 Node.js 内部使用。这里有一个简单的视图来描绘其大概。</p><p><img src="https://user-images.githubusercontent.com/1475173/40290010-30290030-5cee-11e8-9bb1-3fb6faae7359.png" alt></p><p>引擎包括两个主要组件：</p><ul><li>动态内存管理 － 在这里分配内存</li><li>调用栈－这里代码执行即是你的堆栈结构</li></ul><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>几乎每个 JavaScript 开发者都使用过一些浏览器 API(比如 setTimeout)。然而这些 API并不是引擎所提供的。</p><p>那么它们从何而来？</p><p>事实上这个情况有点复杂呃。。</p><p><img src="https://user-images.githubusercontent.com/1475173/40288048-fc615fc2-5ce3-11e8-9f1e-e96489238538.png" alt></p><p>所以，除了引擎但是实际上还有更多其它方面的东西。有被称为 Web API 的东西，这些 Web API 是由浏览器提供的，比如 DOM,AJAX,setTimeout 以及其它。</p><p>于是乎，就有了流行的事件循环和回调队列。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>JavaScript 只是一个单线程的编程语言，这意味着它只有一个调用栈。这样它只能一次做一件事情。</p><p>调用栈是一种数据结构，里面会记录我们在程序中的大概位置。当执行进入一个函数，把它置于栈的顶部。如果从函数中返回则从栈顶部移除函数。这就是调用栈所能够做的事情。</p><p>举个栗子。查看如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>当引擎开始执行这段代码的时候，调用栈会被清空。之后，产生如下步骤：</p><p><img src="https://user-images.githubusercontent.com/1475173/40290072-74dee8fc-5cee-11e8-97bf-23d11571e8a6.png" alt></p><p>调用栈中的每个入口被称为堆栈结构。</p><p>当抛出异常的时候这正好是堆栈追踪是如何被构造出来的－当发生异常的时候这基本上是调用栈的状态。看下如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes:)'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>如果在 Chrome 中执行（假设代码在 foo.js 的文件中），将会产生如下的堆栈追踪：</p><p><img src="https://user-images.githubusercontent.com/1475173/40290093-8c12a194-5cee-11e8-8efa-c5c0bee2df74.png" alt></p><p>“堆栈溢出”－当你达到最大调用栈大小的时候发生。这种情况相当容易发生，特别是当你使用递归而没有仔细地检查代码的时候。查看下如下代码：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  foo();</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><p>当引擎开始执行这段代码的时候，它开始调用 foo 函数。这个函数，然而，会递归并开始调用其自身而没有任何结束条件。所以在每步执行过程中，调用堆栈会反复地添加同样的函数。执行过程如下所示：</p><p><img src="https://user-images.githubusercontent.com/1475173/40290111-a126eb12-5cee-11e8-8fe5-ff36434c7013.png" alt></p><p>在某一时刻，然而，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，这样浏览器决定抛出错误的动作，如下所示：</p><p><img src="https://user-images.githubusercontent.com/1475173/40290127-b46b631a-5cee-11e8-8437-9e42419b2a48.png" alt></p><p>在单线程中运行代码会相当轻松因为你不用处理多线程环境中产生的一些复杂情况，比如死锁。</p><p>但是在单线程运行代码也会有相当的限制。由于 JavaScript 只有一个调用栈，如果运行很慢会发生什么？</p><h2 id="并发和事件循环"><a href="#并发和事件循环" class="headerlink" title="并发和事件循环"></a>并发和事件循环</h2><p>当你在调用栈中有函数为了完成运行需要消耗大量的时间的时候会发生什么？例如，想象一下你想要在浏览器用 JavaScript 来执行一些复杂的图像转化。</p><p>你或许会问－为什么这也是个问题？问题是这样的当调用栈有函数需要执行，浏览器实际上不能做其它任何事－它被阻塞了。这意味着浏览器不能够执行渲染，它不能够运行其它代码，它卡住了。如果你想要在 app 中拥有酷炫的流畅 UI 体验，这将会是个问题。</p><p>这不会是唯一的问题。一旦浏览器开始在调用栈中执行如此多的任务，浏览器将会在相当一段时间内停止交互。大多数浏览器会抛出一个错误，询问你是否关闭网页。</p><p><img src="https://user-images.githubusercontent.com/1475173/40287991-b76a14b8-5ce3-11e8-9808-242e1c6501ba.jpeg" alt></p><p>现在，这并不是最好的用户体验，难道不是吗？</p><p>因此，如何不阻塞 UI 且不让浏览器停止响应来执行运行缓慢的代码呢？使用异步回调。</p><p>这将会在 『JavaScript 工作原理』 第二章：『在V8 引擎中如何写最佳代码的 5 条小技巧』中进行详细阐述。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文请查阅&lt;a href=&quot;https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，本文采用&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知识共享署名 4.0 国际许可协议&lt;/a&gt;共享，BY &lt;a href=&quot;https://github.com/Troland&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Troland&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这是  JavaScript 工作原理的第一章。本章会对语言引擎，运行时，调用栈做一个概述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着 JavaScript 越来越流行，团队也利用其在他们诸如前端，后端，混合 apps，嵌入设备以及更多设备等开发栈中的不同层面的支持。&lt;/p&gt;
&lt;p&gt;本章系列的第一章，本系列旨在深入 JavaScript  并理解它是如何运行的：我们认为在了解 JavaScript 的构建模块和它们是如何捏合在一起工作之后你将会写出更好的代码和 apps。我们将会分享一些当在创建 &lt;a href=&quot;https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=source&amp;utm_content=javascript-series-post1-intro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SessionStack&lt;/a&gt; 时候的经验法则，&lt;a href=&quot;https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=source&amp;utm_content=javascript-series-post1-intro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SessionStack&lt;/a&gt; 是一个轻量级的 JavaScript 程序它拥有强壮性和高性能的优点以保持竞争力。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
